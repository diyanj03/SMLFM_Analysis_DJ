import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import to_rgba
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from scipy.stats import shapiro, ttest_ind, mannwhitneyu, levene, f as f_dist
import os
import pandas as pd
import seaborn as sns

# Extracting data from 4P classifier output
def extracting_confPerc_values(results_directory):
    """
    Args: path of results directory generated by the MATLAB tracking data analysis
    Return: list of confPerc values from PerFOVstats.csv
    """
    perfovstats_filepath = os.path.join(results_directory, 'AllTrajectories', 'PerFOVstats.csv')
    if not os.path.exists(perfovstats_filepath):
        raise FileNotFoundError(f"File not found: {perfovstats_filepath}")
    
    df = pd.read_csv(perfovstats_filepath)

    # Filter out NaNs and negative values
    confPerc_list = df['confPerc']
    confPerc_list = confPerc_list[confPerc_list.notna() & (confPerc_list >= 0)].tolist()

    return confPerc_list

def extract_biophysical_param(results_dir, param, conf_or_unconf_or_all):
    csv_path = os.path.join(results_dir, conf_or_unconf_or_all, f'{param}.csv')
    df = pd.read_csv(csv_path)
    
    np_avg_diffusionConst_list = [] 

    for x in (df['datasetIdx']).unique():
        df_perfov = df[df['datasetIdx'] == x]
        np_avg_diffusionConst_list.append(np.mean(df_perfov[param]))
    
    avg_param_distribution = [float(x) for x in np_avg_diffusionConst_list]

    return avg_param_distribution 


def jitter_boxplot(distribution_lists, sample_labels, parameter, ylabel = None, unit = None,
                   scatter_transparency=0.8, boxplot_shade_transparency=0.4, boxplot_line_width=2,
                   figWidth= 0.8, figHeight = 4.8, boxplot_widths = 0.7, jitter_std=0.1127,
                   xTickRotationAngle = 45, tickLabelSize = 12, yLabelFontSize = 13, axesThickness = 2, 
                   show_annotations = True, annotationBaseGap=0.08, annotationStackGap=0.1, annotationTextGap = 0.0,
                   annotationLineWidth = 2, annotationFontSize = 12,
                   force_ylim_0 = False, force_ylim_max = None, set_ylim_min=None, rgb_list = None, destination_dir=None):

    if len(distribution_lists) == 1:
        show_annotations=False

    
    if rgb_list == None:
        base_colors = ['slateblue', 'indianred', 'seagreen', 'peru', 'steelblue', 'palevioletred', 'teal', 'slategray', 'gray', 'olive', 'cyan']
        rgb_list = [base_colors[i % len(base_colors)] for i in range(len(distribution_lists))]

    if ylabel == None:
        ylabel = parameter

    fig_width = 1.5 + figWidth * len(distribution_lists)

    plt.figure(figsize=(fig_width, figHeight))

    boxplots = plt.boxplot(
        distribution_lists,
        tick_labels=sample_labels,
        widths=boxplot_widths,
        medianprops=dict(color='black'),
        boxprops=dict(linewidth=boxplot_line_width),
        whiskerprops=dict(linewidth=boxplot_line_width),
        capprops=dict(linewidth=boxplot_line_width),
        patch_artist=True
    )

    # Colour the boxes after creating them
    for patch, rgb in zip(boxplots['boxes'], rgb_list):
        face_rgba = to_rgba(rgb, alpha=boxplot_shade_transparency)
        patch.set_facecolor(face_rgba)
        patch.set_edgecolor((0, 0, 0, 1))  # opaque black edge
        patch.set_linewidth(boxplot_line_width)

    # Now add jitter only to non-outliers
    for i, (vals, box, rgb) in enumerate(zip(distribution_lists, boxplots['boxes'], rgb_list), start=1):
        whiskers = boxplots['whiskers'][2*(i-1):2*i]
        lower_whisker = whiskers[0].get_ydata()[1]
        upper_whisker = whiskers[1].get_ydata()[1]
        
        vals = np.array(vals)
        x_vals = np.full_like(vals, fill_value=i, dtype=float)
        
        non_outliers = (vals >= lower_whisker) & (vals <= upper_whisker)
        outliers = ~non_outliers

        jitter = np.random.normal(0, jitter_std, size=len(vals))
        jitter[outliers] = 0
        
        x_jittered = x_vals + jitter
        
        # Plot non-outliers with jitter
        plt.scatter(x_jittered[non_outliers], vals[non_outliers], color=rgb, alpha=scatter_transparency)
        # Plot outliers without jitter (aligned exactly)
        plt.scatter(x_vals[outliers], vals[outliers], color=rgb, alpha=scatter_transparency)  # optional: different marker for outliers

    plt.tick_params(axis='both', labelsize=tickLabelSize)  # increases tick label size

    plt.ylabel(ylabel, fontsize = yLabelFontSize)
    plt.xticks(rotation=xTickRotationAngle) 

    ax = plt.gca()
    for spine in ax.spines.values():
        spine.set_linewidth(axesThickness)                   # axes border thickness

    ax.tick_params(axis='both', width=2, length=6, labelsize=14)  # tick width, length, label size


    means = {label: np.mean(data) for label, data in zip(sample_labels, distribution_lists)}
    stds = {label: np.std(data) for label, data in zip(sample_labels, distribution_lists)}

    normality_results = {}
    for label, data in zip(sample_labels, distribution_lists):
        stat, p = shapiro(data)
        normality_results[label] = {'statistic': stat, 'p_value': p, 'normal': p > 0.05}

    def get_significance_symbol(p):
        if p < 0.0001: return "****"
        elif p < 0.001: return "***"
        elif p < 0.01: return "**"
        elif p < 0.05: return "*"
        else: return "ns"

    max_vals = [np.max(data) for data in distribution_lists]
    min_vals = [np.min(data) for data in distribution_lists]

    if force_ylim_max:
        maxx_val = force_ylim_max
    else: 
        maxx_val = max(max_vals)
    
    if set_ylim_min:
        minn_val = set_ylim_min
    else: 
        minn_val = min(min_vals)
    
    if force_ylim_0:
        minn_val = 0

    base_gap = (maxx_val - minn_val) * annotationBaseGap
    stack_gap = (maxx_val - minn_val) * annotationStackGap

    annotationTextGap = 0.0

    annotations = []
    test_results = {}

    for i in range(len(distribution_lists)):
        for j in range(i + 1, len(distribution_lists)):
            label_i, label_j = sample_labels[i], sample_labels[j]
            normal_i = normality_results[label_i]['normal']
            normal_j = normality_results[label_j]['normal']

            if normal_i and normal_j:
                test_name = 't-test'
                stat, p_value = ttest_ind(distribution_lists[i], distribution_lists[j], equal_var=False)
                var_test_name = "f-test"
                var1 = np.var(distribution_lists[i], ddof=1)
                var2 = np.var(distribution_lists[j], ddof=1)
                if var1 > var2:
                    F = var1 / var2
                    dfn = len(distribution_lists[i]) - 1
                    dfd = len(distribution_lists[j]) - 1
                else:
                    F = var2 / var1
                    dfn = len(distribution_lists[j]) - 1
                    dfd = len(distribution_lists[i]) - 1
                var_stat = F
                var_p_value = 2 * min(f_dist.cdf(F, dfn, dfd), 1 - f_dist.cdf(F, dfn, dfd))
            else:
                test_name = 'mannwhitney'
                stat, p_value = mannwhitneyu(distribution_lists[i], distribution_lists[j], alternative='two-sided')
                var_test_name = "levene's"
                var_stat, var_p_value = levene(distribution_lists[i], distribution_lists[j], center='median')

            sig_symbol = get_significance_symbol(p_value)
            var_sig_symbol = get_significance_symbol(var_p_value)

            pair_key = f"{label_i} vs {label_j}"
            test_results[pair_key] = {
                'test': test_name, 'statistic': stat, 'p_value': p_value, 'significance': sig_symbol,
                'var_test': var_test_name, 'var_statistic': var_stat, 'var_p_value': var_p_value, 'var_significance': var_sig_symbol
            }

            x1, x2 = i + 1, j + 1
            local_max = max(max_vals[i], max_vals[j])
            y = local_max + base_gap

            intermediate_indices = [k for k in range(len(distribution_lists)) if x1 < (k + 1) < x2]
            if intermediate_indices:
                intermediate_max = max([max_vals[k] for k in intermediate_indices])
                if intermediate_max + base_gap > y:
                    y = intermediate_max + base_gap

            annotations.append({'x1': x1, 'x2': x2, 'y': y, 'sig_symbol': sig_symbol})

    annotations.sort(key=lambda x: x['y'])
    for idx in range(1, len(annotations)):
        if annotations[idx]['y'] - annotations[idx - 1]['y'] < stack_gap:
            annotations[idx]['y'] = annotations[idx - 1]['y'] + stack_gap

    all_values = np.concatenate(distribution_lists)

    if show_annotations:
        max_annotation_y = 0
        for ann in annotations:
            plt.plot([ann['x1'], ann['x2']], [ann['y'], ann['y']], color='black', linewidth=annotationLineWidth)
            plt.text((ann['x1'] + ann['x2']) / 2, ann['y'] + annotationTextGap, ann['sig_symbol'], ha='center', va='bottom', fontsize = annotationFontSize)
            max_annotation_y = max(max_annotation_y, ann['y'] + annotationTextGap + 0.25*stack_gap)
    else:
        max_annotation_y = np.max(all_values)
    
    if force_ylim_0: 
        padding = 0.1 * (np.max(all_values) - 0)
        lower_limit = 0
        upper_limit = max_annotation_y + padding
    else:
        padding = 0.1 * (np.max(all_values) - np.min(all_values))
        lower_limit = np.min(all_values) - padding
        upper_limit = max_annotation_y + padding

    if force_ylim_max:
        upper_limit = force_ylim_max

    if set_ylim_min:
        lower_limit = set_ylim_min
    
    plt.ylim(lower_limit, upper_limit)


    plt.tight_layout()
    if destination_dir:
        os.makedirs(destination_dir, exist_ok=True)
        plot_path = os.path.join(destination_dir, f"{'_'.join(sample_labels)}_{parameter}_jitterPlots.pdf")
        plot_path2 = os.path.join(destination_dir, f"{'_'.join(sample_labels)}_{parameter}_jitterPlots.png")
        plt.savefig(plot_path)
        plt.savefig(plot_path2, dpi=600)
    plt.show()

    if unit:
        unit_label = f'({unit})'
    else:
        unit_label  = ''
    txt = f"=== {ylabel} - Stats Summary ===\n\n"
    txt += f">> Means {unit_label}:\n"
    for label in sample_labels:
        txt += f"{label}: {means[label]:.5f}\n"
    txt += f"\n>> Standard Deviations {unit_label}:\n"
    for label in sample_labels:
        txt += f"{label}: {stds[label]:.5f}\n"
    txt += "\n>> Normality Test (Shapiro-Wilk):\n"
    for label in sample_labels:
        res = normality_results[label]
        norm_str = "Normal" if res['normal'] else "Not normal"
        txt += f"{label}: statistic = {res['statistic']:.4f}, p = {res['p_value']:.4f} → {norm_str}\n"
    txt += "\n>> Pairwise Significance Tests:\n"
    for pair, res in test_results.items():
        txt += f"{pair}: {res['test']} | stat = {res['statistic']:.4f}, p = {res['p_value']:.4g}, sig = {res['significance']}\n"
        txt += f"{pair}: {res['var_test']} | stat = {res['var_statistic']:.4f}, p = {res['var_p_value']:.4g}, sig = {res['var_significance']}\n"

    # print(txt)
    if destination_dir:
        txt_path = os.path.join(destination_dir, f"{'_'.join(sample_labels)}_{parameter}_stats.txt")
        with open(txt_path, 'w', encoding='utf-8') as f:
            f.write(txt)


def get_ylims(distribution_lists, show_annotations, annotationBaseGap, annotationStackGap, force_ylim_0,):

    if len(distribution_lists) == 1:
        show_annotations = False

    max_vals = [np.max(data) for data in distribution_lists]
    min_vals = [np.min(data) for data in distribution_lists]

    maxx_val = max(max_vals)
    minn_val = 0 if force_ylim_0 else min(min_vals)

    base_gap = (maxx_val - minn_val) * annotationBaseGap
    stack_gap = (maxx_val - minn_val) * annotationStackGap

    all_values = np.concatenate(distribution_lists)

    if show_annotations:
        sample_labels = [str(i) for i in range(len(distribution_lists))]
        annotations = []
        for i in range(len(distribution_lists)):
            for j in range(i + 1, len(distribution_lists)):
                x1, x2 = i + 1, j + 1
                local_max = max(max_vals[i], max_vals[j])
                y = local_max + base_gap

                intermediate_indices = [k for k in range(len(distribution_lists)) if x1 < (k + 1) < x2]
                if intermediate_indices:
                    intermediate_max = max([max_vals[k] for k in intermediate_indices])
                    if intermediate_max + base_gap > y:
                        y = intermediate_max + base_gap

                annotations.append({'x1': x1, 'x2': x2, 'y': y})

        annotations.sort(key=lambda x: x['y'])
        for idx in range(1, len(annotations)):
            if annotations[idx]['y'] - annotations[idx - 1]['y'] < stack_gap:
                annotations[idx]['y'] = annotations[idx - 1]['y'] + stack_gap

        max_annotation_y = max(a['y'] for a in annotations) if annotations else max(all_values)
    else:
        max_annotation_y = max(all_values)

    if force_ylim_0:
        padding = 0.1 * (np.max(all_values) - 0)
        lower_limit = 0
    else:
        padding = 0.1 * (np.max(all_values) - np.min(all_values))
        lower_limit = np.min(all_values) - padding

    upper_limit = max_annotation_y + padding

    return lower_limit, upper_limit

def get_max_min_ylim(results_dir_list, param, show_annotations, annotationBaseGap, annotationStackGap, force_ylim_0):
    distribution_lists_unconf = [extract_biophysical_param(results_dir, param, 'Unconfined') for results_dir in results_dir_list]
    distribution_lists_conf = [extract_biophysical_param(results_dir, param, 'Confined') for results_dir in results_dir_list]

    unconf_lower, unconf_upper = get_ylims(distribution_lists_unconf, show_annotations, annotationBaseGap, annotationStackGap, force_ylim_0)
    conf_lower, conf_upper = get_ylims(distribution_lists_conf, show_annotations, annotationBaseGap, annotationStackGap, force_ylim_0)

    if unconf_lower > conf_lower:
        non_min_seg_state = 'Unconfined'
        min_lower = conf_lower
    else:
        non_min_seg_state = 'Confined'
        min_lower = unconf_lower

    if unconf_upper > conf_upper:
        non_max_seg_state = 'Confined'
        max_upper = unconf_upper
    else:
        non_max_seg_state = 'Unconfined'
        max_upper = conf_upper
    
    return (min_lower, non_min_seg_state), (max_upper, non_max_seg_state)

def batchProcess_4Pparams(results_dir_list, sample_labels, root_directory,
                            sync_axes=True, time_interval=500,
                            scatter_transparency=0.8, boxplot_shade_transparency=0.4, boxplot_line_width=2,
                            figWidth= 0.8, figHeight = 4.8, boxplot_widths = 0.7, jitter_std=0.1127,
                            xTickRotationAngle = 45, tickLabelSize = 12, yLabelFontSize = 12, axesThickness = 2, 
                            show_annotations = True, annotationBaseGap=0.08, annotationStackGap=0.1, annotationTextGap = 0.0,
                            annotationLineWidth = 2, annotationFontSize = 12,
                            force_ylim_0 = False, rgb_list = None):
    
    """
    Generates jittered boxplots for biophysical parameters (e.g. alpha) between multiple sample conditions.

    Parameters:
        results_dir_list (list): List of paths to 4P classifier output directories per sample.
        sample_labels (list): Labels corresponding to each sample directory in the same order.
        root_directory (str): root directory.
        show_annotations (bool, optional): Whether to annotate significance between groups.
        force_ylim_0 (bool, optional): If True, y-axis lower limit is fixed at 0 for all plots.
        sync_axes (bool, optional): Whether to synchronise y-axis limits between 'confined' and 'unconfined' states.
        rgb_list (list, optional): Custom RGB colours for each group.
        annotationBaseGap (float, optional): Gap between box and annotation line.
        annotationStackGap (float, optional): Vertical offset between stacked annotations.
        annotationTextGap (float, optional): Vertical offset of annotation text.
        annotationLineWidth (float, optional): Thickness of annotation lines.
        annotationFontSize (int, optional): Font size of annotation text.
        time_interval (float, optional): Frame interval (ms) to determine segmentation state labels.
        scatter_transparency (float, optional): Level of opaqueness of scatter points.
        boxplot_shade_transparency (float, optional): Level of opaqueness of boxplot fills.
        boxplot_line_width (float, optional): Thickness of boxplot lines.
        figWidth (float, optional): Figure width.
        figHeight (float, optional): Fixed figure height.
        boxplot_widths (float, optional): Width of individual boxplots.
        jitter_std (float, optional): Standard deviation of x-axis jitter.
        xTickRotationAngle (float, optional): Angle for x-tick labels.
        tickLabelSize (int, optional): Font size for tick labels.
        yLabelFontSize (int, optional): Font size for y-axis label.
        axesThickness (int, optional): Thickness of axis spines.
    Notes:
        Plots and statistical summaries are saved in the 'results' directory under `root_directory`.
    """

    def get_segmentation_state_label(time_interval, segmentation_state):
        if time_interval < 50:
            if segmentation_state == 'Confined':
                return 'Chromatin-Bound'
            elif segmentation_state == 'Unconfined':
                return 'Freely-Diffusing'
            elif segmentation_state == 'AllTrajectories':
                return 'All'
        else:
            if segmentation_state == 'Confined':
                return 'Slow-Diffusing'
            elif segmentation_state == 'Unconfined':
                return 'Fast-Diffusing'
            elif segmentation_state == 'AllTrajectories':
                return 'All'
    
    def get_unit(param):
        if param == 'alpha':
            return ''
        elif param == 'diffusionConst':
            return 'μm²/s'
        elif param == 'driftMagnitude':
            return 'μm/s'
        elif param == 'Lc':
            return 'μm'


    results_dir = os.path.join(root_directory, 'results')
    os.makedirs(results_dir, exist_ok=True)

    param_list = ['confPerc','alpha', 'diffusionConst', 'driftMagnitude', 'Lc']
    # param_list = ['alpha']
    segmentation_state_list = ['Confined', 'Unconfined', 'AllTrajectories']

    for param in param_list: 
        if param == 'confPerc': # using param as parameter for saving path
            distribution_lists = [extracting_confPerc_values(results_dir) for results_dir in results_dir_list]
            ylabel = 'Percentage of Trajectories Confined (%)'
            unit = None
            dst_dir = os.path.join(results_dir, '_'.join(sample_labels) + '_perFOV_results', param)
            force_ylim_max = None
            set_ylim_min = None
            jitter_boxplot(distribution_lists=distribution_lists, sample_labels=sample_labels, parameter=param, ylabel=ylabel, unit=unit,
                scatter_transparency=scatter_transparency, boxplot_shade_transparency=boxplot_shade_transparency, boxplot_line_width=boxplot_line_width,
                figWidth=figWidth, figHeight=figHeight, boxplot_widths=boxplot_widths, jitter_std=jitter_std,
                xTickRotationAngle=xTickRotationAngle, tickLabelSize=tickLabelSize, yLabelFontSize=yLabelFontSize, axesThickness=axesThickness, 
                show_annotations=show_annotations, annotationBaseGap=annotationBaseGap, annotationStackGap=annotationStackGap, annotationTextGap=annotationTextGap,
                annotationLineWidth=annotationLineWidth, annotationFontSize=annotationFontSize,
                force_ylim_0=force_ylim_0, force_ylim_max=force_ylim_max, set_ylim_min=set_ylim_min, rgb_list=rgb_list, destination_dir=dst_dir)

        else:
            (lower, non_lower_segState), (upper, non_upper_segState) = get_max_min_ylim(results_dir_list, param, show_annotations, annotationBaseGap, annotationStackGap, force_ylim_0)

            for seg_state in segmentation_state_list:
                # print(f'\n{seg_state}:')
                distribution_lists = [extract_biophysical_param(results_dir, param, seg_state) for results_dir in results_dir_list]
                seg_state_label = get_segmentation_state_label(time_interval, seg_state)
                unit = get_unit(param)
                ylabel = f'Mean {param} - {seg_state_label} Trajectories ({unit})'
                dst_dir = os.path.join(results_dir, '_'.join(sample_labels) + '_perFOV_results', param, seg_state)
                
                force_ylim_max = None
                set_ylim_min = None

                if seg_state == non_upper_segState:
                    if sync_axes:
                        force_ylim_max = upper
                    else:
                        force_ylim_max = None
                
                if seg_state == non_lower_segState:
                    if sync_axes:
                        set_ylim_min = lower
                    else:
                        set_ylim_min = None
            
                jitter_boxplot(distribution_lists=distribution_lists, sample_labels=sample_labels, parameter=param, ylabel=ylabel, unit=unit,
                                scatter_transparency=scatter_transparency, boxplot_shade_transparency=boxplot_shade_transparency, boxplot_line_width=boxplot_line_width,
                                figWidth=figWidth, figHeight=figHeight, boxplot_widths=boxplot_widths, jitter_std=jitter_std,
                                xTickRotationAngle=xTickRotationAngle, tickLabelSize=tickLabelSize, yLabelFontSize=yLabelFontSize, axesThickness=axesThickness, 
                                show_annotations=show_annotations, annotationBaseGap=annotationBaseGap, annotationStackGap=annotationStackGap, annotationTextGap=annotationTextGap,
                                annotationLineWidth=annotationLineWidth, annotationFontSize=annotationFontSize,
                                force_ylim_0=force_ylim_0, force_ylim_max=force_ylim_max, set_ylim_min=set_ylim_min, rgb_list=rgb_list, destination_dir=dst_dir)

    print(f"Successfully saved plots and stats of biophysical params to {os.path.join(results_dir, '_'.join(sample_labels) + '_perFOV_results')}")

def batchProcess_analysisMetrics(csv_list, sample_labels, root_directory,
                   scatter_transparency=0.8, boxplot_shade_transparency=0.4, boxplot_line_width=2,
                   figWidth= 0.8, figHeight = 4.8, boxplot_widths = 0.7, jitter_std=0.1127,
                   xTickRotationAngle = 45, tickLabelSize = 12, yLabelFontSize = 13, axesThickness = 2, 
                   show_annotations = True, annotationBaseGap=0.08, annotationStackGap=0.1, annotationTextGap = 0.0,
                   annotationLineWidth = 2, annotationFontSize = 12,
                   force_ylim_0 = False, force_ylim_max = None, set_ylim_min=None, rgb_list = None):

    """
    Generates jittered boxplots for smflm analysis metrics between multiple sample conditions.

    Parameters:
        csv_list (list): List of paths to analysis summary stats csv files generated from cell 9 per sample.
        sample_labels (list): Labels corresponding to each sample directory in the same order.
        root_directory (str): Root directory. 
        show_annotations (bool, optional): Whether to annotate significance between groups.
        force_ylim_0 (bool, optional): If True, y-axis lower limit is fixed at 0 for all plots.
        sync_axes (bool, optional): Whether to synchronise y-axis limits between 'confined' and 'unconfined' states.
        rgb_list (list, optional): List of custom RGB colours in same sample type order as csv_list.
        annotationBaseGap (float, optional): Gap between box and annotation line.
        annotationStackGap (float, optional): Vertical offset between stacked annotations.
        annotationTextGap (float, optional): Vertical offset of annotation text.
        annotationLineWidth (float, optional): Thickness of annotation lines.
        annotationFontSize (int, optional): Font size of annotation text.
        time_interval (float, optional): Frame interval (ms) to determine segmentation state labels.
        scatter_transparency (float, optional): Level of opaqueness of scatter points.
        boxplot_shade_transparency (float, optional): Level of opaqueness of boxplot fills.
        boxplot_line_width (float, optional): Thickness of boxplot lines.
        figWidth (float, optional): Figure width.
        figHeight (float, optional): Fixed figure height.
        boxplot_widths (float, optional): Width of individual boxplots.
        jitter_std (float, optional): Standard deviation of x-axis jitter.
        xTickRotationAngle (float, optional): Angle for x-tick labels.
        tickLabelSize (int, optional): Font size for tick labels.
        yLabelFontSize (int, optional): Font size for y-axis label.
        axesThickness (int, optional): Thickness of axis spines.
    Notes:
        Plots and statistical summaries are saved in the 'results/analysisMetrics' directory under `root_directory`.
    """

    def define_ylabel_units(column_heading):
        if column_heading == 'num_2Dlocs_perframe':
            ylabel = f'Number of 2D localisations per 1000 frames'
            unit = None

        if column_heading == 'num_raw3Dlocs_perframe':
            ylabel = f'Number of raw 3D localisations per 1000 frames'
            unit = None

        if column_heading == 'num_cropped3Dlocs_perframe':
            ylabel = f'Number of processed 3D localisations per 1000 frames'
            unit = None

        if column_heading == 'numTracks_perframe':
            ylabel = f'Number of tracks per 1000 frames'
            unit = None

        if column_heading == 'mean_axialPrecision':
            ylabel = f'Mean Axial Precision (nm)'
            unit = 'nm'

        if column_heading == 'mean_lateralPrecision':
            ylabel = f'Mean Lateral Precision (nm)'
            unit = 'nm'
        
        return ylabel, unit
        

    for column_heading in ['num_2Dlocs_perframe', 'num_raw3Dlocs_perframe', 'num_cropped3Dlocs_perframe', 'numTracks_perframe', 'mean_axialPrecision', 'mean_lateralPrecision']:
        
        distribution_lists = []
        skip_column = False

        for path in csv_list:
            df = pd.read_csv(path)
            if column_heading not in df.columns:
                print(f"Column '{column_heading}' not found in {path}, skipping this parameter.")
                skip_column = True
                break
            values = df[column_heading].dropna().tolist()
            
            if column_heading in ['num_2Dlocs_perframe', 'num_raw3Dlocs_perframe', 'num_cropped3Dlocs_perframe', 'numTracks_perframe']:
                values = np.array(values)
                mod_values = 1000*values
                distribution_lists.append(mod_values.tolist())
            else:
                distribution_lists.append(values)


        if skip_column:
            continue

        if all(len(lst) == 0 for lst in distribution_lists):
            print(f"No data found for column '{column_heading}', skipping.")
            continue

        ylabel, unit = define_ylabel_units(column_heading)
        param = column_heading.replace('perframes', 'per1000frames')

        dst_dir = os.path.join(root_directory, 'results', '_'.join(sample_labels) + '_perFOV_results', 'analysisMetrics', param)
        os.makedirs(dst_dir, exist_ok=True)

        jitter_boxplot(distribution_lists=distribution_lists, sample_labels=sample_labels, parameter=param, ylabel=ylabel, unit=unit,
                        scatter_transparency=scatter_transparency, boxplot_shade_transparency=boxplot_shade_transparency, boxplot_line_width=boxplot_line_width,
                        figWidth=figWidth, figHeight=figHeight, boxplot_widths=boxplot_widths, jitter_std=jitter_std,
                        xTickRotationAngle=xTickRotationAngle, tickLabelSize=tickLabelSize, yLabelFontSize=yLabelFontSize, axesThickness=axesThickness, 
                        show_annotations=show_annotations, annotationBaseGap=annotationBaseGap, annotationStackGap=annotationStackGap, annotationTextGap=annotationTextGap,
                        annotationLineWidth=annotationLineWidth, annotationFontSize=annotationFontSize,
                        force_ylim_0=force_ylim_0, force_ylim_max=force_ylim_max, set_ylim_min=set_ylim_min, rgb_list=rgb_list, destination_dir=dst_dir)
    print(f"Successfully saved plots and stats of image analysis metrics to {os.path.join(root_directory, 'results', '_'.join(sample_labels) + '_perFOV_results', 'analysisMetrics')}")


# Association value +- 95% confidence interval of multiple samples.
def plotAssociationValues(results_dir_list, sample_names, root_directory):
    """
    Args: 
    - results_dir_list: list of names of results directories to be analysed
    - sample_names: custom names for each dataset in respective order or results_dir_list
    - root directory path.
    """

    all_data = []

    # Ensure the sample_dirs and sample_names lists are the same length
    if len(results_dir_list) != len(sample_names):
        raise ValueError("The number of directories must match the number of sample names.")

    for results_dir, sample_name in zip(results_dir_list, sample_names):
    
        filepath = os.path.join(results_dir, 'Association', 'HistogramFit_best.csv')
        
        if os.path.exists(filepath):
            df = pd.read_csv(filepath)

            sample_data = {'source': [sample_name]}

            # Find all columns that start with 'tau_' (e.g., tau_1, tau_2, etc.)
            tau_columns = [col for col in df.columns if col.startswith('tau_')]

            for tau_col in tau_columns:
                # Extract the first row for the tau value (central value)
                tau_value = df.loc[0, tau_col]

              
                tau_lower = df.loc[1, tau_col]
                tau_upper = df.loc[2, tau_col]

                sample_data[f'{tau_col}'] = [tau_value]
                sample_data[f'{tau_col}_lower'] = [tau_lower]
                sample_data[f'{tau_col}_upper'] = [tau_upper]

            
            all_data.append(pd.DataFrame(sample_data))

    # Concatenate all data frames from different directories
    results_df = pd.concat(all_data, ignore_index=True)

    def plotting_association_values(ass_data, root_directory):
        plt.figure(figsize=(5, 4))  

        tau_columns = [col for col in ass_data.columns if col.startswith('tau_') and not col.endswith('_lower') and not col.endswith('_upper')]

        for tau_col in tau_columns:
            sns.scatterplot(data=ass_data, x='source', y=tau_col, label=tau_col, s=75, marker='X')

            tau_lower = ass_data[f'{tau_col}_lower']
            tau_upper = ass_data[f'{tau_col}_upper']
            plt.errorbar(
                ass_data['source'],
                ass_data[tau_col],
                yerr=[ass_data[tau_col] - tau_lower, tau_upper - ass_data[tau_col]],
                fmt='none',
                capsize=4,
                ecolor='gray' 
            )

        plt.xticks(rotation=45)
        plt.ylabel('Association Time (s)')
        plt.xlabel('')
        plt.legend()
        plt.margins(x=0.3)
        plt.tight_layout()

        destination_dir = os.path.join(root_directory, 'results')
        os.makedirs(destination_dir, exist_ok=True)

        destination_subdir = os.path.join(destination_dir, '_'.join(sample_names) + '_perFOV_results', 'Association')

        os.makedirs(destination_subdir, exist_ok=True)
        destination_path = os.path.join(destination_subdir, '_'.join(sample_names) + '_associationValues.pdf')

        plt.savefig(destination_path)
        plt.show()

        stats_file_path = os.path.join(destination_subdir, '_'.join(sample_names) + '_stats.txt')

        with open(stats_file_path, 'w') as fileHandle:
            for i, row in results_df.iterrows():
                fileHandle.write('=== association values (tau) and 95% confidence intervals (tau_lower and tau_upper) ===\n\n')
                fileHandle.write(f"Sample: {row['source']}\n")
                tau_cols = [col for col in results_df.columns if col.startswith('tau_') and not col.endswith('_lower') and not col.endswith('_upper')]
                for tau_col in tau_cols:
                    val = round(row[tau_col], 4)
                    lower = round(row[tau_col + '_lower'], 4)
                    upper = round(row[tau_col + '_upper'], 4)
                    fileHandle.write(f"  {tau_col} = {val} | {tau_col}_lower = {lower} | {tau_col}_upper = {upper}\n")
                fileHandle.write("\n")


    # Generate the plot
    plotting_association_values(results_df, root_directory)


